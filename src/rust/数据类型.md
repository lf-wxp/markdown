# æ•°æ®ç±»å‹

## ç±»å‹è½¬æ¢

### åŸç”Ÿç±»å‹

Rust ä¸æä¾›`åŸç”Ÿç±»å‹`ä¹‹é—´çš„éšå¼ç±»å‹è½¬æ¢ï¼ˆcoercionï¼‰ï¼Œä½†å¯ä»¥ä½¿ç”¨ as å…³é”®å­—è¿›è¡Œæ˜¾ å¼ç±»å‹è½¬æ¢ï¼ˆcastingï¼‰ã€‚
<mark>å½“æŠŠ`ä»»ä½•ç±»å‹`è½¬æ¢ä¸ºæ— ç¬¦å·ç±»å‹ T æ—¶ï¼Œä¼šä¸æ–­åŠ ä¸Šæˆ–å‡å» (std::T::MAX + 1),ç›´åˆ°å€¼ä½äºæ–°ç±»å‹ T çš„èŒƒå›´å†…ã€‚</mark>

```rust
// ä¸æ˜¾ç¤ºç±»å‹è½¬æ¢äº§ç”Ÿçš„æº¢å‡ºè­¦å‘Šã€‚
#![allow(overflowing_literals)]

fn main() {
  let decimal = 65.4321_f32;

  // é”™è¯¯ï¼ä¸æä¾›éšå¼è½¬æ¢
  // let integer: u8 = decimal;
  // æ”¹æ­£ ^ æ³¨é‡Šæ‰è¿™ä¸€è¡Œ

  // å¯ä»¥æ˜¾å¼è½¬æ¢
  let integer = decimal as u8;
  let character = integer as char; // Açš„ASCIIç ä¸º65

  println!("Casting: {} -> {} -> {}", decimal, integer, character);

  // å½“æŠŠä»»ä½•ç±»å‹è½¬æ¢ä¸ºæ— ç¬¦å·ç±»å‹ T æ—¶ï¼Œä¼šä¸æ–­åŠ ä¸Šæˆ–å‡å» (std::T::MAX + 1)
  // ç›´åˆ°å€¼ä½äºæ–°ç±»å‹ T çš„èŒƒå›´å†…ã€‚

  let single_char = 'A';
  let unicode = 'ğŸ˜‡';
  println!("single char is {}", single_char as u8);
  println!("single unicode is {}", unicode as u8);
  println!("128519 mod 256 {}", 128519 % 256);

  // 1000 å·²ç»åœ¨ u16 çš„èŒƒå›´å†…
  println!("1000 as a u16 is: {}", 1000 as u16);

  // 1000 - 256 - 256 - 256 = 232
  // äº‹å®ä¸Šçš„å¤„ç†æ–¹å¼æ˜¯ï¼šä»æœ€ä½æœ‰æ•ˆä½ï¼ˆLSBï¼Œleast significant bitsï¼‰å¼€å§‹ä¿ç•™
  // 8 ä½ï¼Œç„¶åå‰©ä½™ä½ç½®ï¼Œç›´åˆ°æœ€é«˜æœ‰æ•ˆä½ï¼ˆMSBï¼Œmost significant bitï¼‰éƒ½è¢«æŠ›å¼ƒã€‚
  // è¯‘æ³¨ï¼šMSB å°±æ˜¯äºŒè¿›åˆ¶çš„æœ€é«˜ä½ï¼ŒLSB å°±æ˜¯äºŒè¿›åˆ¶çš„æœ€ä½ä½ï¼ŒæŒ‰æ—¥å¸¸ä¹¦å†™ä¹ æƒ¯å°±æ˜¯
  // æœ€å·¦è¾¹ä¸€ä½å’Œæœ€å³è¾¹ä¸€ä½ã€‚
  println!("1000 as a u8 is : {}", 1000 as u8);
  // -1 + 256 = 255
  println!("  -1 as a u8 is : {}", (-1i8) as u8);

  // å¯¹æ­£æ•°ï¼Œè¿™å°±å’Œå–æ¨¡ä¸€æ ·ã€‚
  println!("1000 mod 256 is : {}", 1000 % 256);

  // å½“è½¬æ¢åˆ°æœ‰ç¬¦å·ç±»å‹æ—¶ï¼Œï¼ˆä½æ“ä½œçš„ï¼‰ç»“æœå°±å’Œ â€œå…ˆè½¬æ¢åˆ°å¯¹åº”çš„æ— ç¬¦å·ç±»å‹ï¼Œ
  // å¦‚æœ MSB æ˜¯ 1ï¼Œåˆ™è¯¥å€¼ä¸ºè´Ÿâ€ æ˜¯ä¸€æ ·çš„ã€‚

  // å½“ç„¶å¦‚æœæ•°å€¼å·²ç»åœ¨ç›®æ ‡ç±»å‹çš„èŒƒå›´å†…ï¼Œå°±ç›´æ¥æŠŠå®ƒæ”¾è¿›å»ã€‚
  println!(" 128 as a i16 is: {}", 128 as i16);
  // 128 è½¬æˆ u8 è¿˜æ˜¯ 128ï¼Œä½†è½¬åˆ° i8 ç›¸å½“äºç»™ 128 å–å…«ä½çš„äºŒè¿›åˆ¶è¡¥ç ï¼Œå…¶å€¼æ˜¯ï¼š
  println!(" 128 as a i8 is : {}", 128 as i8);

  // é‡å¤ä¹‹å‰çš„ä¾‹å­
  // 1000 as u8 -> 232
  println!("1000 as a u8 is : {}", 1000 as u8);
  // 232 çš„äºŒè¿›åˆ¶è¡¥ç æ˜¯ -24
  println!(" 232 as a i8 is : {}", 232 as i8);
}
```

### éåŸç”Ÿç±»å‹

Rust ä½¿ç”¨ trait è§£å†³ç±»å‹ä¹‹é—´çš„è½¬æ¢é—®é¢˜ã€‚æœ€ä¸€èˆ¬çš„è½¬æ¢ä¼šç”¨åˆ° From å’Œ into ä¸¤ä¸ª traitã€‚ä¸è¿‡ï¼Œå³ä¾¿å¸¸è§çš„æƒ…å†µä¹Ÿå¯èƒ½ä¼šç”¨åˆ°ç‰¹åˆ«çš„ traitï¼Œå°¤å…¶æ˜¯ ä» String è½¬æ¢åˆ°åˆ«çš„ç±»å‹ï¼Œä»¥åŠæŠŠåˆ«çš„ç±»å‹è½¬æ¢åˆ° String æ—¶ã€‚

#### From å’Œ Into

`From` traitå…è®¸ä¸€ç§ç±»å‹å®šä¹‰ â€œæ€ä¹ˆæ ¹æ®å¦ä¸€ç§ç±»å‹ç”Ÿæˆè‡ªå·±â€ï¼Œå› æ­¤å®ƒæä¾›äº†ä¸€ç§ç±»å‹è½¬æ¢çš„ç®€å•æœºåˆ¶ã€‚åœ¨æ ‡å‡†åº“ä¸­æœ‰æ— æ•°`From` çš„å®ç°ï¼Œè§„å®šåŸç”Ÿç±»å‹åŠå…¶ä»–å¸¸è§ç±»å‹çš„è½¬æ¢åŠŸèƒ½ã€‚

`Into` trait å°±æ˜¯æŠŠ`From` trait å€’è¿‡æ¥è€Œå·²ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä½ ä¸ºä½ çš„ç±»å‹å®ç°äº†`From`ï¼Œé‚£ä¹ˆåŒæ—¶ä½ ä¹Ÿå°±å…è´¹è·å¾—äº†`Into`ã€‚

```rust
use std::convert::From;

#[derive(Debug)]
struct Number {
  value: i32,
}

impl From<i32> for Number {
  fn from(item: i32) -> Self {
    Number { value: item }
  }
}

// é’ˆå¯¹ä¸åŒç±»å‹å®ç°trait
impl From<char> for Number {
  fn from(item: char) -> Self {
    Number { value: item as i32 }
  }
}

fn main() {
  let int = 5;
  // è¯•è¯•åˆ é™¤ç±»å‹è¯´æ˜
  let num: Number = int.into();
  let num = Number::from(int);
  let num = Number::from('A');
  println!("My number is {:?}", num);
}
```

### TryFrom å’Œ TryInto

ç±»ä¼¼äº`From`å’Œ`Into`ï¼Œ`TryFrom` å’Œ`TryInto`æ˜¯ ç±»å‹è½¬æ¢çš„é€šç”¨ traitã€‚ä¸åŒäº `From/Into` çš„æ˜¯ï¼Œ`TryFrom`å’Œ`TryInto` trait ç”¨äºæ˜“å‡ºé”™çš„è½¬æ¢ï¼Œä¹Ÿæ­£å› å¦‚æ­¤ï¼Œå…¶è¿”å›å€¼æ˜¯`Result`å‹ã€‚

```rust
use std::convert::TryFrom;
use std::convert::TryInto;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32);

impl TryFrom<i32> for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -> Result<Self, Self::Error> {
      if value % 2 == 0 {
        Ok(EvenNumber(value))
      } else {
        Err(())
      }
    }
}

fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result<EvenNumber, ()> = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result<EvenNumber, ()> = 5i32.try_into();
    assert_eq!(result, Err(()));
}
```

### ToString å’Œ FromStr

#### `ToString`

è¦æŠŠä»»ä½•ç±»å‹è½¬æ¢æˆ `String`ï¼Œåªéœ€è¦å®ç°é‚£ä¸ªç±»å‹çš„ `ToString` traitã€‚ç„¶è€Œä¸è¦ç›´æ¥è¿™ä¹ˆåšï¼Œ<mark>æ‚¨åº”è¯¥å®ç°`fmt::Display` traitï¼Œå®ƒä¼šè‡ªåŠ¨æä¾› `ToString`ï¼Œå¹¶ä¸”è¿˜å¯ä»¥ç”¨æ¥æ‰“å°ç±»å‹ï¼Œå°±åƒ `print!` ä¸€èŠ‚ä¸­è®¨è®ºçš„é‚£æ ·ã€‚<mark/>

```rust
use std::string::ToString;
use std::fmt::{Display, Formatter, Result};

struct Circle {
    radius: i32
}

impl ToString for Circle {
  fn to_string(&self) -> String {
    format!("Circle of radius {:?}", self.radius)
  }
}

// Display trait å’Œ ToString trait å®ç°å…¶ä¸­ä¸€ä¸ªå³å¯
impl Display for Circle {
  fn fmt(&self, f: &mut Formatter) -> Result {
    write!(f, "{}", self.radius)
  }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!("{}", circle.to_string());
}
```

#### `FromStr'

æˆ‘ä»¬ç»å¸¸éœ€è¦æŠŠå­—ç¬¦ä¸²è½¬æˆæ•°å­—ã€‚å®Œæˆè¿™é¡¹å·¥ä½œçš„æ ‡å‡†æ‰‹æ®µæ˜¯ç”¨ `parse` å‡½æ•°ã€‚æˆ‘ä»¬å¾—
æä¾›è¦è½¬æ¢åˆ°çš„ç±»å‹ï¼Œè¿™å¯ä»¥é€šè¿‡ä¸ä½¿ç”¨ç±»å‹æ¨æ–­ï¼Œæˆ–è€…ç”¨ â€œæ¶¡è½®é±¼â€ è¯­æ³•ï¼ˆturbo
 fishï¼Œ`<>`ï¼‰å®ç°ã€‚

åªè¦å¯¹ç›®æ ‡ç±»å‹å®ç°äº† `FromStr` traitï¼Œå°±å¯ä»¥ç”¨ `parse` æŠŠå­—ç¬¦ä¸²è½¬æ¢æˆç›®æ ‡ç±»å‹ã€‚
æ ‡å‡†åº“ä¸­å·²ç»ç»™æ— æ•°ç§ç±»å‹å®ç°äº† `FromStr`ã€‚å¦‚æœè¦è½¬æ¢åˆ°ç”¨æˆ·å®šä¹‰ç±»å‹ï¼Œåªè¦æ‰‹åŠ¨å®ç°
 `FromStr` å°±è¡Œã€‚

```rust
fn main() {
   let parsed: i32 = "5".parse().unwrap();
   let turbo_parsed = "10".parse::<i32>().unwrap();

   let sum = parsed + turbo_parsed;
   println!{"Sum: {:?}", sum};
}
```

## ç±»å‹åˆ«å

å¯ä»¥ç”¨ type è¯­å¥ç»™å·²æœ‰çš„ç±»å‹å–ä¸ªæ–°çš„åå­—ã€‚ç±»å‹çš„åå­—å¿…é¡»éµå¾ªå¤§é©¼å³°å‘½åã€‚ä¹Ÿå¯ç”¨æ³¨è§£å¿½ç•¥`#[allow(non_camel_case_types)]`.
